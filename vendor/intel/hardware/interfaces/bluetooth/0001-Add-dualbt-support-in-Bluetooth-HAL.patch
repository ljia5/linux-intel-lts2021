From bed62efea107763e9e2a9549da880bcb12269ffe Mon Sep 17 00:00:00 2001
From: Gowtham Anandha Babu <gowtham.anandha.babu@intel.com>
Date: Thu, 21 Sep 2023 19:31:41 +0530
Subject: [PATCH] Add dualbt support in Bluetooth HAL

Introduced new "ext" instance of Bluetooth HAL for auxiliary
Bluetooth adapter.

Verified both instances ("default", "ext") getting called for
respective primary and auxiliary Bluetooth adapters.

Tracked-On: OAM-112407
Signed-off-by: Gowtham Anandha Babu <gowtham.anandha.babu@intel.com>
---
 bluetooth/Android.bp                          |   1 +
 ...roid.hardware.bluetooth@1.0-service.vbt.rc |   2 +
 bluetooth/bluetooth_hci.cc                    | 126 ++++--
 bluetooth/bluetooth_hci.h                     |   3 +-
 bluetooth/service.cpp                         |   7 +-
 bluetooth/vendor_interface.cc                 |  12 +-
 bluetooth/vendor_interface_ext.cc             | 390 ++++++++++++++++++
 bluetooth/vendor_interface_ext.h              |  76 ++++
 8 files changed, 567 insertions(+), 50 deletions(-)
 create mode 100644 bluetooth/vendor_interface_ext.cc
 create mode 100644 bluetooth/vendor_interface_ext.h

diff --git a/bluetooth/Android.bp b/bluetooth/Android.bp
index c6611a9..aa32cfe 100644
--- a/bluetooth/Android.bp
+++ b/bluetooth/Android.bp
@@ -26,6 +26,7 @@ cc_binary {
         "bluetooth_hci.cc",
         "bluetooth_address.cc",
         "vendor_interface.cc",
+        "vendor_interface_ext.cc",
         "hci_packetizer.cc",
         "hci_protocol.cc",
         "h4_protocol.cc",
diff --git a/bluetooth/android.hardware.bluetooth@1.0-service.vbt.rc b/bluetooth/android.hardware.bluetooth@1.0-service.vbt.rc
index af765bf..b8b8d2b 100644
--- a/bluetooth/android.hardware.bluetooth@1.0-service.vbt.rc
+++ b/bluetooth/android.hardware.bluetooth@1.0-service.vbt.rc
@@ -1,4 +1,6 @@
 service vendor.bluetooth-1-0 /vendor/bin/hw/android.hardware.bluetooth@1.0-service.vbt
+    interface android.hardware.bluetooth@1.0::IBluetoothHci default
+    interface android.hardware.bluetooth@1.0::IBluetoothHci ext
     class hal
     capabilities BLOCK_SUSPEND NET_ADMIN SYS_NICE
     user bluetooth
diff --git a/bluetooth/bluetooth_hci.cc b/bluetooth/bluetooth_hci.cc
index f789310..4c860f8 100644
--- a/bluetooth/bluetooth_hci.cc
+++ b/bluetooth/bluetooth_hci.cc
@@ -20,6 +20,7 @@
 #include <log/log.h>
 
 #include "vendor_interface.h"
+#include "vendor_interface_ext.h"
 
 namespace android {
 namespace hardware {
@@ -50,12 +51,17 @@ class BluetoothDeathRecipient : public hidl_death_recipient {
   bool has_died_;
 };
 
-BluetoothHci::BluetoothHci()
-    : death_recipient_(new BluetoothDeathRecipient(this)) {}
+/* Currently we support two adapters which is being passed
+ * from service.cpp, "default" and "ext". adapter_name_ can
+ * be one of these two values.
+ */
+BluetoothHci::BluetoothHci(const char *name) :
+      death_recipient_(new BluetoothDeathRecipient(this)) ,
+      adapter_name_(name) {}
 
 Return<void> BluetoothHci::initialize(
     const ::android::sp<IBluetoothHciCallbacks>& cb) {
-  ALOGI("BluetoothHci::initialize()");
+  ALOGI("BluetoothHci::initialize() %s", adapter_name_.c_str());
   if (cb == nullptr) {
     ALOGE("cb == nullptr! -> Unable to call initializationComplete(ERR)");
     return Void();
@@ -63,40 +69,73 @@ Return<void> BluetoothHci::initialize(
 
   death_recipient_->setHasDied(false);
   cb->linkToDeath(death_recipient_, 0);
-
-  bool rc = VendorInterface::Initialize(
-      [cb](bool status) {
-        auto hidl_status = cb->initializationComplete(
-            status ? Status::SUCCESS : Status::INITIALIZATION_ERROR);
-        if (!hidl_status.isOk()) {
-          ALOGE("VendorInterface -> Unable to call initializationComplete()");
-        }
-      },
-      [cb](const hidl_vec<uint8_t>& packet) {
-        auto hidl_status = cb->hciEventReceived(packet);
-        if (!hidl_status.isOk()) {
-          ALOGE("VendorInterface -> Unable to call hciEventReceived()");
-        }
-      },
-      [cb](const hidl_vec<uint8_t>& packet) {
-        auto hidl_status = cb->aclDataReceived(packet);
-        if (!hidl_status.isOk()) {
-          ALOGE("VendorInterface -> Unable to call aclDataReceived()");
-        }
-      },
-      [cb](const hidl_vec<uint8_t>& packet) {
-        auto hidl_status = cb->scoDataReceived(packet);
-        if (!hidl_status.isOk()) {
-          ALOGE("VendorInterface -> Unable to call scoDataReceived()");
-        }
-      });
-  if (!rc) {
-    auto hidl_status = cb->initializationComplete(Status::INITIALIZATION_ERROR);
-    if (!hidl_status.isOk()) {
-      ALOGE("VendorInterface -> Unable to call initializationComplete(ERR)");
+  if (adapter_name_.compare("ext") == 0) {
+    bool rc = VendorInterfaceExt::Initialize(
+        [cb](bool status) {
+          auto hidl_status = cb->initializationComplete(
+              status ? Status::SUCCESS : Status::INITIALIZATION_ERROR);
+          if (!hidl_status.isOk()) {
+            ALOGE("VendorInterfaceExt -> Unable to call initializationComplete()");
+          }
+        },
+        [cb](const hidl_vec<uint8_t>& packet) {
+          auto hidl_status = cb->hciEventReceived(packet);
+          if (!hidl_status.isOk()) {
+            ALOGE("VendorInterfaceExt -> Unable to call hciEventReceived()");
+          }
+        },
+        [cb](const hidl_vec<uint8_t>& packet) {
+          auto hidl_status = cb->aclDataReceived(packet);
+          if (!hidl_status.isOk()) {
+            ALOGE("VendorInterfaceExt -> Unable to call aclDataReceived()");
+          }
+        },
+        [cb](const hidl_vec<uint8_t>& packet) {
+          auto hidl_status = cb->scoDataReceived(packet);
+          if (!hidl_status.isOk()) {
+            ALOGE("VendorInterfaceExt -> Unable to call scoDataReceived()");
+          }
+        });
+    if (!rc) {
+      auto hidl_status = cb->initializationComplete(Status::INITIALIZATION_ERROR);
+      if (!hidl_status.isOk()) {
+        ALOGE("VendorInterfaceExt -> Unable to call initializationComplete(ERR)");
+      }
+    }
+  } else {
+    bool rc = VendorInterface::Initialize(
+        [cb](bool status) {
+          auto hidl_status = cb->initializationComplete(
+              status ? Status::SUCCESS : Status::INITIALIZATION_ERROR);
+          if (!hidl_status.isOk()) {
+            ALOGE("VendorInterface -> Unable to call initializationComplete()");
+          }
+        },
+        [cb](const hidl_vec<uint8_t>& packet) {
+          auto hidl_status = cb->hciEventReceived(packet);
+          if (!hidl_status.isOk()) {
+            ALOGE("VendorInterface -> Unable to call hciEventReceived()");
+          }
+        },
+        [cb](const hidl_vec<uint8_t>& packet) {
+          auto hidl_status = cb->aclDataReceived(packet);
+          if (!hidl_status.isOk()) {
+            ALOGE("VendorInterface -> Unable to call aclDataReceived()");
+          }
+        },
+        [cb](const hidl_vec<uint8_t>& packet) {
+          auto hidl_status = cb->scoDataReceived(packet);
+          if (!hidl_status.isOk()) {
+            ALOGE("VendorInterface -> Unable to call scoDataReceived()");
+          }
+        });
+    if (!rc) {
+      auto hidl_status = cb->initializationComplete(Status::INITIALIZATION_ERROR);
+      if (!hidl_status.isOk()) {
+        ALOGE("VendorInterface -> Unable to call initializationComplete(ERR)");
+      }
     }
   }
-
   unlink_cb_ = [cb](sp<BluetoothDeathRecipient>& death_recipient) {
     if (death_recipient->getHasDied())
       ALOGI("Skipping unlink call, service died.");
@@ -110,7 +149,11 @@ Return<void> BluetoothHci::initialize(
 Return<void> BluetoothHci::close() {
   ALOGI("BluetoothHci::close()");
   unlink_cb_(death_recipient_);
-  VendorInterface::Shutdown();
+  if (adapter_name_.compare("ext") == 0) {
+    VendorInterfaceExt::Shutdown();
+  } else {
+    VendorInterface::Shutdown();
+  }
   return Void();
 }
 
@@ -131,11 +174,16 @@ Return<void> BluetoothHci::sendScoData(const hidl_vec<uint8_t>& data) {
 
 void BluetoothHci::sendDataToController(const uint8_t type,
                                         const hidl_vec<uint8_t>& data) {
-  VendorInterface::get()->Send(type, data.data(), data.size());
+  if (adapter_name_.compare("ext") == 0) {
+    VendorInterfaceExt::get()->Send(type, data.data(), data.size());
+  } else {
+    VendorInterface::get()->Send(type, data.data(), data.size());
+  }
 }
 
-IBluetoothHci* HIDL_FETCH_IBluetoothHci(const char* /* name */) {
-  return new BluetoothHci();
+IBluetoothHci* HIDL_FETCH_IBluetoothHci(const char*  name) {
+  ALOGI("BluetoothHci::HIDL_FETCH_IBluetoothHci() %s", name);
+  return new BluetoothHci(name);
 }
 
 }  // namespace implementation
diff --git a/bluetooth/bluetooth_hci.h b/bluetooth/bluetooth_hci.h
index e2797b1..5950876 100644
--- a/bluetooth/bluetooth_hci.h
+++ b/bluetooth/bluetooth_hci.h
@@ -36,7 +36,7 @@ class BluetoothDeathRecipient;
 
 class BluetoothHci : public IBluetoothHci {
  public:
-  BluetoothHci();
+  BluetoothHci(const char *name);
   Return<void> initialize(
       const ::android::sp<IBluetoothHciCallbacks>& cb) override;
   Return<void> sendHciCommand(const hidl_vec<uint8_t>& packet) override;
@@ -48,6 +48,7 @@ class BluetoothHci : public IBluetoothHci {
   void sendDataToController(const uint8_t type, const hidl_vec<uint8_t>& data);
   ::android::sp<BluetoothDeathRecipient> death_recipient_;
   std::function<void(sp<BluetoothDeathRecipient>&)> unlink_cb_;
+  const std::string adapter_name_;
 };
 
 extern "C" IBluetoothHci* HIDL_FETCH_IBluetoothHci(const char* name);
diff --git a/bluetooth/service.cpp b/bluetooth/service.cpp
index a96552b..f775f9f 100644
--- a/bluetooth/service.cpp
+++ b/bluetooth/service.cpp
@@ -30,8 +30,11 @@ using ::android::hardware::joinRpcThreadpool;
 using ::android::sp;
 
 int main(int /* argc */, char** /* argv */) {
-  sp<IBluetoothHci> bluetooth = new BluetoothHci;
+  ALOGI("BT HAL service");
+  sp<IBluetoothHci> bluetooth = new BluetoothHci("default");
+  sp<IBluetoothHci> bluetoothext = new BluetoothHci("ext");
   configureRpcThreadpool(1, true);
-  bluetooth->registerAsService();
+  bluetooth->registerAsService("default");
+  bluetoothext->registerAsService("ext");
   joinRpcThreadpool();
 }
diff --git a/bluetooth/vendor_interface.cc b/bluetooth/vendor_interface.cc
index 1e0df7b..bbee000 100644
--- a/bluetooth/vendor_interface.cc
+++ b/bluetooth/vendor_interface.cc
@@ -195,8 +195,9 @@ bool VendorInterface::Open(InitializeCompleteCallback initialize_complete_cb,
   initialize_complete_cb_ = initialize_complete_cb;
 
   // Initialize vendor interface
-
+  ALOGD("%s open (%s)", __func__, VENDOR_LIBRARY_NAME);
   lib_handle_ = dlopen(VENDOR_LIBRARY_NAME, RTLD_NOW);
+
   if (!lib_handle_) {
     ALOGE("%s unable to open %s (%s)", __func__, VENDOR_LIBRARY_NAME,
           dlerror());
@@ -211,13 +212,8 @@ bool VendorInterface::Open(InitializeCompleteCallback initialize_complete_cb,
     return false;
   }
 
-  // Get the local BD address
-
-  uint8_t local_bda[BluetoothAddress::kBytes];
-  if (!BluetoothAddress::get_local_address(local_bda)) {
-    LOG_ALWAYS_FATAL("%s: No Bluetooth Address!", __func__);
-  }
-  int status = lib_interface_->init(&lib_callbacks, (unsigned char*)local_bda);
+  unsigned char local_bda[8] = "default";
+  int status = lib_interface_->init(&lib_callbacks, local_bda);
   if (status) {
     ALOGE("%s unable to initialize vendor library: %d", __func__, status);
     return false;
diff --git a/bluetooth/vendor_interface_ext.cc b/bluetooth/vendor_interface_ext.cc
new file mode 100644
index 0000000..ffea53d
--- /dev/null
+++ b/bluetooth/vendor_interface_ext.cc
@@ -0,0 +1,390 @@
+//
+// Copyright 2016 The Android Open Source Project
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+
+#include "vendor_interface_ext.h"
+
+#define LOG_TAG "android.hardware.bluetooth@1.0-service.vbt"
+#include <cutils/properties.h>
+#include <utils/Log.h>
+
+#include <dlfcn.h>
+#include <fcntl.h>
+
+#include "bluetooth_address.h"
+#include "h4_protocol.h"
+#include "mct_protocol.h"
+
+typedef uint8_t UINT8;
+typedef uint16_t UINT16;
+
+#define STREAM_TO_UINT8(u8, p)   {u8 = (UINT8)(*(p)); (p) += 1;}
+#define STREAM_TO_UINT16(u16, p) {u16 = ((UINT16)(*(p)) + (((UINT16)(*((p) + 1))) << 8)); (p) += 2;}
+
+static const char* VENDOR_AUX_LIBRARY_NAME = "libbt-vendor.so";
+static const char* VENDOR_LIBRARY_SYMBOL_NAME =
+    "BLUETOOTH_VENDOR_LIB_INTERFACE";
+
+static const int INVALID_FD = -1;
+
+namespace {
+
+using android::hardware::bluetooth::V1_0::implementation::VendorInterfaceExt;
+using android::hardware::hidl_vec;
+
+struct {
+  tINT_CMD_CBACK cb;
+  uint16_t opcode;
+} internal_command;
+
+// True when LPM is not enabled yet or wake is not asserted.
+bool lpm_wake_deasserted;
+uint32_t lpm_timeout_ms;
+bool recent_activity_flag;
+
+VendorInterfaceExt* g_vendor_interface_ext = nullptr;
+std::mutex wakeup_mutex_;
+
+HC_BT_HDR* WrapPacketAndCopy(uint16_t event, const hidl_vec<uint8_t>& data) {
+  size_t packet_size = data.size() + sizeof(HC_BT_HDR);
+  HC_BT_HDR* packet = reinterpret_cast<HC_BT_HDR*>(new uint8_t[packet_size]);
+  packet->offset = 0;
+  packet->len = data.size();
+  packet->layer_specific = 0;
+  packet->event = event;
+  // TODO(eisenbach): Avoid copy here; if BT_HDR->data can be ensured to
+  // be the only way the data is accessed, a pointer could be passed here...
+  memcpy(packet->data, data.data(), data.size());
+  return packet;
+}
+
+bool internal_command_event_match(const hidl_vec<uint8_t>& packet) {
+  uint8_t event_code = packet[0];
+  if (event_code != HCI_COMMAND_COMPLETE_EVENT) {
+    ALOGE("%s: Unhandled event type %02X", __func__, event_code);
+    return false;
+  }
+
+  size_t opcode_offset = HCI_EVENT_PREAMBLE_SIZE + 1;  // Skip num packets.
+
+  uint16_t opcode = packet[opcode_offset] | (packet[opcode_offset + 1] << 8);
+
+  ALOGV("%s internal_command.opcode = %04X opcode = %04x", __func__,
+        internal_command.opcode, opcode);
+  return opcode == internal_command.opcode;
+}
+
+uint8_t transmit_cb(uint16_t opcode, void* buffer, tINT_CMD_CBACK callback) {
+  ALOGV("%s opcode: 0x%04x, ptr: %p, cb: %p", __func__, opcode, buffer,
+        callback);
+  internal_command.cb = callback;
+  internal_command.opcode = opcode;
+  uint8_t type = HCI_PACKET_TYPE_COMMAND;
+  HC_BT_HDR* bt_hdr = reinterpret_cast<HC_BT_HDR*>(buffer);
+  VendorInterfaceExt::get()->Send(type, bt_hdr->data, bt_hdr->len);
+  delete[] reinterpret_cast<uint8_t*>(buffer);
+  return true;
+}
+
+void firmware_config_cb(bt_vendor_op_result_t result) {
+  ALOGV("%s result: %d", __func__, result);
+  VendorInterfaceExt::get()->OnFirmwareConfigured(result);
+}
+
+void sco_config_cb(bt_vendor_op_result_t result) {
+  ALOGD("%s result: %d", __func__, result);
+}
+
+void low_power_mode_cb(bt_vendor_op_result_t result) {
+  ALOGD("%s result: %d", __func__, result);
+}
+
+void sco_audiostate_cb(bt_vendor_op_result_t result) {
+  ALOGD("%s result: %d", __func__, result);
+}
+
+void* buffer_alloc_cb(int size) {
+  void* p = new uint8_t[size];
+  ALOGV("%s pts: %p, size: %d", __func__, p, size);
+  return p;
+}
+
+void buffer_free_cb(void* buffer) {
+  ALOGV("%s ptr: %p", __func__, buffer);
+  delete[] reinterpret_cast<uint8_t*>(buffer);
+}
+
+void epilog_cb(bt_vendor_op_result_t result) {
+  ALOGD("%s result: %d", __func__, result);
+}
+
+void a2dp_offload_cb(bt_vendor_op_result_t result, bt_vendor_opcode_t op,
+                     uint8_t av_handle) {
+  ALOGD("%s result: %d, op: %d, handle: %d", __func__, result, op, av_handle);
+}
+
+const bt_vendor_callbacks_t lib_callbacks = {
+    sizeof(lib_callbacks), firmware_config_cb, sco_config_cb,
+    low_power_mode_cb,     sco_audiostate_cb,  buffer_alloc_cb,
+    buffer_free_cb,        transmit_cb,        epilog_cb,
+    a2dp_offload_cb};
+
+}  // namespace
+
+namespace android {
+namespace hardware {
+namespace bluetooth {
+namespace V1_0 {
+namespace implementation {
+
+class FirmwareStartupTimer {
+ public:
+  FirmwareStartupTimer() : start_time_(std::chrono::steady_clock::now()) {}
+
+  ~FirmwareStartupTimer() {
+    std::chrono::duration<double> duration =
+        std::chrono::steady_clock::now() - start_time_;
+    double s = duration.count();
+    if (s == 0) return;
+    ALOGI("Firmware configured in %.3fs", s);
+  }
+
+ private:
+  std::chrono::steady_clock::time_point start_time_;
+};
+
+bool VendorInterfaceExt::Initialize(
+    InitializeCompleteCallback initialize_complete_cb,
+    PacketReadCallback event_cb, PacketReadCallback acl_cb,
+    PacketReadCallback sco_cb) {
+  if (g_vendor_interface_ext) {
+    ALOGE("%s: No previous Shutdown()?", __func__);
+    return false;
+  }
+  g_vendor_interface_ext = new VendorInterfaceExt();
+  return g_vendor_interface_ext->Open(initialize_complete_cb, event_cb, acl_cb,
+                                  sco_cb);
+}
+
+void VendorInterfaceExt::Shutdown() {
+  LOG_ALWAYS_FATAL_IF(!g_vendor_interface_ext, "%s: No Vendor ext interface!",
+                      __func__);
+  g_vendor_interface_ext->Close();
+  delete g_vendor_interface_ext;
+  g_vendor_interface_ext = nullptr;
+}
+
+VendorInterfaceExt* VendorInterfaceExt::get() { return g_vendor_interface_ext; }
+
+bool VendorInterfaceExt::Open(InitializeCompleteCallback initialize_complete_cb,
+                           PacketReadCallback event_cb,
+                           PacketReadCallback acl_cb,
+                           PacketReadCallback sco_cb) {
+  initialize_complete_cb_ = initialize_complete_cb;
+
+  // Initialize vendor interface
+  ALOGD("%s open (%s)", __func__, VENDOR_AUX_LIBRARY_NAME);
+  lib_handle_ = dlopen(VENDOR_AUX_LIBRARY_NAME, RTLD_NOW);
+
+  if (!lib_handle_) {
+    ALOGE("%s unable to open %s (%s)", __func__, VENDOR_AUX_LIBRARY_NAME,
+          dlerror());
+    return false;
+  }
+
+  lib_interface_ = reinterpret_cast<bt_vendor_interface_t*>(
+      dlsym(lib_handle_, VENDOR_LIBRARY_SYMBOL_NAME));
+  if (!lib_interface_) {
+    ALOGE("%s unable to find symbol %s in %s (%s)", __func__,
+          VENDOR_LIBRARY_SYMBOL_NAME, VENDOR_AUX_LIBRARY_NAME, dlerror());
+    return false;
+  }
+
+  unsigned char local_bda[8] = "ext";
+  int status = lib_interface_->init(&lib_callbacks, local_bda);
+  if (status) {
+    ALOGE("%s unable to initialize vendor library: %d", __func__, status);
+    return false;
+  }
+
+  ALOGD("%s vendor library loaded", __func__);
+
+  // Power on the controller
+
+  int power_state = BT_VND_PWR_ON;
+  lib_interface_->op(BT_VND_OP_POWER_CTRL, &power_state);
+
+  // Get the UART socket(s)
+
+  int fd_list[CH_MAX] = {0};
+  int fd_count = lib_interface_->op(BT_VND_OP_USERIAL_OPEN, &fd_list);
+
+  if (fd_count < 1 || fd_count > CH_MAX - 1) {
+    ALOGE("%s: fd_count %d is invalid!", __func__, fd_count);
+    return false;
+  }
+
+  for (int i = 0; i < fd_count; i++) {
+    if (fd_list[i] == INVALID_FD) {
+      ALOGE("%s: fd %d is invalid!", __func__, fd_list[i]);
+      return false;
+    }
+  }
+
+  event_cb_ = event_cb;
+  PacketReadCallback intercept_events = [this](const hidl_vec<uint8_t>& event) {
+    HandleIncomingEvent(event);
+  };
+
+  if (fd_count == 1) {
+    hci::H4Protocol* h4_hci =
+        new hci::H4Protocol(fd_list[0], intercept_events, acl_cb, sco_cb);
+    fd_watcher_.WatchFdForNonBlockingReads(
+        fd_list[0], [h4_hci](int fd) { h4_hci->OnDataReady(fd); });
+    hci_ = h4_hci;
+  } else {
+    hci::MctProtocol* mct_hci =
+        new hci::MctProtocol(fd_list, intercept_events, acl_cb);
+    fd_watcher_.WatchFdForNonBlockingReads(
+        fd_list[CH_EVT], [mct_hci](int fd) { mct_hci->OnEventDataReady(fd); });
+    fd_watcher_.WatchFdForNonBlockingReads(
+        fd_list[CH_ACL_IN],
+        [mct_hci](int fd) { mct_hci->OnAclDataReady(fd); });
+    hci_ = mct_hci;
+  }
+
+  // Initially, the power management is off.
+  lpm_wake_deasserted = true;
+
+  // Start configuring the firmware
+  firmware_startup_timer_ = new FirmwareStartupTimer();
+  lib_interface_->op(BT_VND_OP_FW_CFG, nullptr);
+
+  return true;
+}
+
+void VendorInterfaceExt::Close() {
+  // These callbacks may send HCI events (vendor-dependent), so make sure to
+  // StopWatching the file descriptor after this.
+  if (lib_interface_ != nullptr) {
+    bt_vendor_lpm_mode_t mode = BT_VND_LPM_DISABLE;
+    lib_interface_->op(BT_VND_OP_LPM_SET_MODE, &mode);
+  }
+
+  fd_watcher_.StopWatchingFileDescriptors();
+
+  if (hci_ != nullptr) {
+    delete hci_;
+    hci_ = nullptr;
+  }
+
+  if (lib_interface_ != nullptr) {
+    lib_interface_->op(BT_VND_OP_USERIAL_CLOSE, nullptr);
+
+    int power_state = BT_VND_PWR_OFF;
+    lib_interface_->op(BT_VND_OP_POWER_CTRL, &power_state);
+
+    lib_interface_->cleanup();
+  }
+
+  if (lib_handle_ != nullptr) {
+    dlclose(lib_handle_);
+    lib_handle_ = nullptr;
+  }
+
+  if (firmware_startup_timer_ != nullptr) {
+    delete firmware_startup_timer_;
+    firmware_startup_timer_ = nullptr;
+  }
+}
+
+size_t VendorInterfaceExt::Send(uint8_t type, const uint8_t* data, size_t length) {
+  std::unique_lock<std::mutex> lock(wakeup_mutex_);
+  recent_activity_flag = true;
+
+  if (lpm_wake_deasserted == true) {
+    // Restart the timer.
+    fd_watcher_.ConfigureTimeout(std::chrono::milliseconds(lpm_timeout_ms),
+                                 [this]() { OnTimeout(); });
+    // Assert wake.
+    lpm_wake_deasserted = false;
+    bt_vendor_lpm_wake_state_t wakeState = BT_VND_LPM_WAKE_ASSERT;
+    lib_interface_->op(BT_VND_OP_LPM_WAKE_SET_STATE, &wakeState);
+    ALOGV("%s: Sent wake before (%02x)", __func__, data[0] | (data[1] << 8));
+  }
+  return hci_->Send(type, data, length);
+}
+
+void VendorInterfaceExt::OnFirmwareConfigured(uint8_t result) {
+  ALOGD("%s result: %d", __func__, result);
+
+  if (firmware_startup_timer_ != nullptr) {
+    delete firmware_startup_timer_;
+    firmware_startup_timer_ = nullptr;
+  }
+
+  if (initialize_complete_cb_ != nullptr) {
+    initialize_complete_cb_(result == 0);
+    initialize_complete_cb_ = nullptr;
+  }
+
+  // Post load
+  lib_interface_->op(BT_VND_OP_SCO_CFG, NULL);
+  ALOGI("%s: SCO configuration initiated ", __func__);
+
+  lib_interface_->op(BT_VND_OP_GET_LPM_IDLE_TIMEOUT, &lpm_timeout_ms);
+  ALOGI("%s: lpm_timeout_ms %d", __func__, lpm_timeout_ms);
+
+  bt_vendor_lpm_mode_t mode = BT_VND_LPM_ENABLE;
+  lib_interface_->op(BT_VND_OP_LPM_SET_MODE, &mode);
+
+  ALOGD("%s Calling StartLowPowerWatchdog()", __func__);
+  fd_watcher_.ConfigureTimeout(std::chrono::milliseconds(lpm_timeout_ms),
+                               [this]() { OnTimeout(); });
+}
+
+void VendorInterfaceExt::OnTimeout() {
+  ALOGV("%s", __func__);
+  std::unique_lock<std::mutex> lock(wakeup_mutex_);
+  if (recent_activity_flag == false) {
+    lpm_wake_deasserted = true;
+    bt_vendor_lpm_wake_state_t wakeState = BT_VND_LPM_WAKE_DEASSERT;
+    lib_interface_->op(BT_VND_OP_LPM_WAKE_SET_STATE, &wakeState);
+    fd_watcher_.ConfigureTimeout(std::chrono::seconds(0), []() {
+      ALOGE("Zero timeout! Should never happen.");
+    });
+  }
+  recent_activity_flag = false;
+}
+
+void VendorInterfaceExt::HandleIncomingEvent(const hidl_vec<uint8_t>& hci_packet) {
+  if (internal_command.cb != nullptr &&
+      internal_command_event_match(hci_packet)) {
+    HC_BT_HDR* bt_hdr = WrapPacketAndCopy(HCI_PACKET_TYPE_EVENT, hci_packet);
+
+    // The callbacks can send new commands, so don't zero after calling.
+    tINT_CMD_CBACK saved_cb = internal_command.cb;
+    internal_command.cb = nullptr;
+    saved_cb(bt_hdr);
+  } else {
+    event_cb_(hci_packet);
+  }
+}
+
+}  // namespace implementation
+}  // namespace V1_0
+}  // namespace bluetooth
+}  // namespace hardware
+}  // namespace android
diff --git a/bluetooth/vendor_interface_ext.h b/bluetooth/vendor_interface_ext.h
new file mode 100644
index 0000000..afd73f5
--- /dev/null
+++ b/bluetooth/vendor_interface_ext.h
@@ -0,0 +1,76 @@
+//
+// Copyright 2016 The Android Open Source Project
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+
+#pragma once
+
+#include <hidl/HidlSupport.h>
+
+#include "async_fd_watcher.h"
+#include "bt_vendor_lib.h"
+#include "hci_protocol.h"
+
+namespace android {
+namespace hardware {
+namespace bluetooth {
+namespace V1_0 {
+namespace implementation {
+
+using ::android::hardware::hidl_vec;
+using InitializeCompleteCallback = std::function<void(bool success)>;
+using PacketReadCallback = std::function<void(const hidl_vec<uint8_t>&)>;
+
+class FirmwareStartupTimer;
+
+class VendorInterfaceExt {
+ public:
+  static bool Initialize(InitializeCompleteCallback initialize_complete_cb,
+                         PacketReadCallback event_cb, PacketReadCallback acl_cb,
+                         PacketReadCallback sco_cb);
+  static void Shutdown();
+  static VendorInterfaceExt *get();
+
+  size_t Send(uint8_t type, const uint8_t *data, size_t length);
+
+  void OnFirmwareConfigured(uint8_t result);
+
+ private:
+  virtual ~VendorInterfaceExt() = default;
+
+  bool Open(InitializeCompleteCallback initialize_complete_cb,
+            PacketReadCallback event_cb, PacketReadCallback acl_cb,
+            PacketReadCallback sco_cb);
+  void Close();
+
+  void OnTimeout();
+
+  void HandleIncomingEvent(const hidl_vec<uint8_t>& hci_packet);
+
+  void *lib_handle_;
+  bt_vendor_interface_t *lib_interface_;
+  async::AsyncFdWatcher fd_watcher_;
+  InitializeCompleteCallback initialize_complete_cb_;
+  hci::HciProtocol* hci_;
+
+  PacketReadCallback event_cb_;
+
+  FirmwareStartupTimer *firmware_startup_timer_;
+};
+
+}  // namespace implementation
+}  // namespace V1_0
+}  // namespace bluetooth
+}  // namespace hardware
+}  // namespace android
-- 
2.17.1

